#!/usr/bin/python
# -*- coding: utf-8 -*-

# todo 正则表达式就是记录文本规则的代码。
# todo python中的正则表达式库，所做的事情是利用正则表达式来搜索文本。

# todo 首先说一种最简单的正则表达式，它没有特殊的符号，只有基本的字母或数字。它满足的匹配规则就是完全匹配。
# todo 例如：有个正则表达式是“hi”，那么它就可以匹配出文本中所有含有hi的字符。

import re

text = "Hi, I am Shirley Hilton. I am his wife."
m = re.findall(r"hi",
               text)  # r"hi",这里字符串前面加了r，是raw的意思，它表示对字符串不进行转义。 re是python里的正则表达式模块。findall是其中一个方法，用来按照提供的正则表达式，去匹配文本中的所有符合条件的字符串。返回结果是一个包含所有匹配的list。
if m:
    print m  # ['hi','hi']  这两个“hi”分别来自“Shirley”和“his”。默认情况下正则表达式是严格区分大小写的，所以“Hi”和“Hilton”中的“Hi”被忽略了。
else:
    print 'not match'

# todo 如果我们只想找到“hi”这个单词，而不把包含它的单词也算在内，那就可以使用“\bhi\b”这个正则表达式。
# todo “\b”在正则表达式中表示单词的开头或结尾，空格、标点、换行都算是单词的分割。而“\b”自身又不会匹配任何字符，它代表的只是一个位置。所以单词前后的空格标点之类不会出现在结果里。

# todo 最后再说一下[]这个符号。在正则表达式中，[]表示满足括号中任一字符。比如“[hi]”，它就不是匹配“hi”了，而是匹配“h”或者“i”。
# todo 在前面例子中，如果把正则表达式改为“[Hh]i”，就可以既匹配“Hi”，又匹配“hi”了。

# todo “.”在正则表达式中表示除换行符以外的任意字符。
m = re.findall(r"i.", text)
if m:
    print m  # ['i,', 'ir', 'il', 'is', 'if']
else:
    print 'not match'

m = re.findall(r".", text)
if m:
    print m  # ['H', 'i', ',', ' ', 'I', ' ', 'a', 'm', ' ', 'S', 'h', 'i', 'r', 'l', 'e', 'y', ' ', 'H', 'i', 'l', 't', 'o', 'n', '.', ' ', 'I', ' ', 'a', 'm', ' ', 'h', 'i', 's', ' ', 'w', 'i', 'f', 'e', '.']
else:
    print 'not match'

# todo 与“.”类似的一个符号是“\S”，它表示的是：不是空白符的任意字符。注意是大写字符S。
m = re.findall(r"\S", text)
if m:
    print m  # ['H', 'i', ',', 'I', 'a', 'm', 'S', 'h', 'i', 'r', 'l', 'e', 'y', 'H', 'i', 'l', 't', 'o', 'n', '.', 'I', 'a', 'm', 'h', 'i', 's', 'w', 'i', 'f', 'e', '.']
else:
    print 'not match'

# todo 在正则表达式中，而“*”则不是表示字符，而是表示数量：它表示前面的字符可以重复任意多次（包括0次），只要满足这样的条件，都会被表达式匹配上。
m = re.findall(r"I.*e", text)
if m:
    print m  # ['I am Shirley Hilton. I am his wife']  这是因为“*”在匹配时，会匹配尽可能长的结果。如果你想让他匹配到最短的就停止，需要用“.*?”。如“I.*?e”，就会得到 ['I am Shirle', 'I am his wife']。这种匹配方式被称为懒惰匹配，而原本尽可能长的方式被称为贪婪匹配。
else:
    print 'not match'

# todo 习题：
# todo 从下面一段文本中，匹配出所有s开头，e结尾的单词。
# todo site sea sue sweet see case sse ssee loses

import re

text = 'site sea sue sweet see case sse ssee loses'
m = re.findall(r"\bs\S*e\b", text)
if m:
    print m  # ['site', 'sue', 'see', 'sse', 'ssee']
else:
    print "no match"

    # todo 正则表达式模式
    # todo     模式                 描述
    # todo    ^                     匹配字符串的开头
    # todo    $                     匹配字符串的末尾。
    # todo    .                     匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。
    # todo   [...]                  用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'
    # todo   [^...]                 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。
    # todo   re*	                匹配0个或多个的表达式。
    # todo   re+	                匹配1个或多个的表达式。
    # todo   re?	                匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式
    # todo   re{ n}
    # todo   re{ n,}	            精确匹配n个前面表达式。
    # todo   re{ n, m}	            匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式
    # todo   a| b	                匹配a或b
    # todo   (re)	                G匹配括号内的表达式，也表示一个组
    # todo   (?imx)	                正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。
    # todo   (?-imx)	            正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
    # todo   (?: re)	            类似 (...), 但是不表示一个组
    # todo   (?imx: re)	            在括号中使用i, m, 或 x 可选标志
    # todo   (?-imx: re)	        在括号中不使用i, m, 或 x 可选标志
    # todo   (?#...)	            注释.
    # todo   (?= re)	            前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。
    # todo   (?! re)	            前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功
    # todo   (?> re)	            匹配的独立模式，省去回溯。
    # todo                          \w	匹配字母数字
    # todo                          \W	匹配非字母数字
    # todo                          \s	匹配任意空白字符，等价于 [\t\n\r\f].
    # todo                          \S	匹配任意非空字符
    # todo                          \d	匹配任意数字，等价于 [0-9].
    # todo                          \D	匹配任意非数字
    # todo                          \A	匹配字符串开始
    # todo                          \Z	匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c
    # todo                          \z	匹配字符串结束
    # todo                          \G	匹配最后匹配完成的位置。
    # todo                          \b	匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
    # todo                          \B	匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
    # todo                          \n, \t, 等.	匹配一个换行符。匹配一个制表符。等
    # todo                          \1...\9	匹配第n个分组的子表达式。
    # todo                          \10	匹配第n个分组的子表达式，如果它经匹配。否则指的是八进制字符码的表达式。


    # todo 正则表达式实例
    # todo 字符匹配
    # todo 实例	                描述
    # todo python	            匹配 "python".

    # todo 字符类
    # todo 实例	                描述
    # todo [Pp]ython	        匹配 "Python" 或 "python"
    # todo rub[ye]	            匹配 "ruby" 或 "rube"
    # todo [aeiou]	            匹配中括号内的任意一个字母
    # todo [0-9]	            匹配任何数字。类似于 [0123456789]
    # todo [a-z]	            匹配任何小写字母
    # todo [A-Z]	            匹配任何大写字母
    # todo [a-zA-Z0-9]	        匹配任何字母及数字
    # todo [^aeiou]	            除了aeiou字母以外的所有字符
    # todo [^0-9]	            匹配除了数字外的字符

    # todo 特殊字符类
    # todo 实例	                描述
    # todo .	                匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。
    # todo \d	                匹配一个数字字符。等价于 [0-9]。
    # todo \D	                匹配一个非数字字符。等价于 [^0-9]。
    # todo \s	                匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
    # todo \S	                匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
    # todo \w	                匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。（3.x版本可以匹配汉字，但2.x版本不可以）
    # todo \W	                匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。

    # todo 习题：
    # todo 写一个正则表达式，能匹配出多种格式的电话号码，包括
    # todo (021)88776543
    # todo 010-55667890
    # todo 02584453362
    # todo 0571 66345673

    # todo \(?0\d{2,3}[) -]?\d{7,8}

    # todo \(?      ()在正则表达式里也有着特殊的含义，所以要匹配字符"("，需要用"\("。?表示这个括号是可有可无的。
    # todo 0\d{2,3}     区号，0xx或者0xxx
    # todo [) -]?       在区号之后跟着的可能是")"、" "、"-"，也可能什么也没有。
    # todo \d{7,8}      7或8位的电话号码
    # todo 这个表达式虽然能匹配出所有正确的数据（一般情况下，这样已经足够），但理论上也会匹配到错误的数据。因为()应当是成对出现的，表达式中对于左右两个括号并没有做关联处理，例如(02188776543这样的数据也是符合条件的。

    # todo 我们可以用正则表达式中的“|”符号解决这种问题。“|”相当于python中“or”的作用，它连接的两个表达式，只要满足其中之一，就会被算作匹配成功。
    # todo 于是我们可以把()的情况单独分离出来： \(0\d{2,3}\)\d{7,8}
    # todo 其他情况： 0\d{2,3}[ -]?\d{7,8}
    # todo 合并： \(0\d{2,3}\)\d{7,8}|0\d{2,3}[ -]?\d{7,8}
    # todo 合并： 使用“|”时，要特别提醒注意的是不同条件之间的顺序。匹配时，会按照从左往右的顺序，一旦匹配成功就停止验证后面的规则。
